<template>
    <div>
        <h2 class="font-weight-bold mb-4">
            Graph
        </h2>

        <Task
            v-for="(item, index) in tasks"
            :key="item.id"
            :title="`${index + 1}. ${item.title}`"
            :description="item.description"
            :description-img="item.descriptionImg"
            :examples="item.examples"
            :solution="item.solution"
            :results="item.results"
            :remember="item.remember"
        />
    </div>
</template>

<script lang='ts'>
import { Component, Vue } from 'nuxt-property-decorator';
import { Task } from '~/types/Task';
import {
    alienOrder,
    canFinish,
    cloneGraph,
    getAmountOfIslands,
    orangesRotting,
    pacificAtlantic,
    surroundedRegions,
} from '~/utils/11-graph';

@Component({
    head: {
        title: 'Practice Graph',
    },
    components: {
        Task: () => import('~/components/ui/Task/Task.vue'),
    },
})
export default class Graph extends Vue {
    tasks: Task[] = [
        {
            title: 'Number of Islands',
            descriptionImg: 'graph.PNG',
            solution: `
            ${getAmountOfIslands.toString().split('\n').join('<br/>')} <br><br>
            `,
            remember: `
                Пройтись по каждой ачейке, найдя начало 1, от нее пройтись слоями через BFS, пока встречаются 1, по всем 4м направлениям, запоминая, что в такие ячейки заходили.
                Если в такую ячейку заходили, или вне поля, или 0, не пополняем очередь этой координатой. Как только поиск закончился, пополняем колво осторовов и  проходим по следующим буквам.
                Если туда заходили, не проходим рекурсией.
           `,
        },
        {
            title: 'Clone Graph',
            descriptionImg: 'graph-1.PNG',
            solution: `
            ${cloneGraph.toString().split('\n').join('<br/>')} <br><br>
            `,
            remember: `
                В хешмапе хранить уже созданную копию такого узла по значению. Пройтись по dfs рекурсии.
                Если такой узел уже есть в мапе, то возвращаем его. Если нет, создаем новый узел с копией значения, пустым
                списком соседей, через цикл проходимся по соседям оригинала, добавляя результат dfs(nei) в массив
                соседей копии. Возвращаем копию
           `,
        },
        {
            title: 'Max Area of Island',
            descriptionImg: 'graph-2.PNG',
            solution: `
            ${pacificAtlantic.toString().split('\n').join('<br/>')} <br><br>
            `,
            remember: `
                Идти от обратного. Определить поочереди, какие из верхей строки и боковой могут стекать в Pacific ocean, проходя dfs,
                сохраняя элементы, не выходящие за края + не присутствующие в visited пасифик океана + текущий эл больше предыдущего. Аналогично для права и низа для
                Атлантического океана. После всего пройтись по одному из хешсетов, найти совпадения.
           `,
        },
        {
            title: 'Surrounded Regions',
            descriptionImg: 'graph-3.PNG',
            solution: `
            ${surroundedRegions.toString().split('\n').join('<br/>')} <br><br>
            `,
            remember: `
                По аналогии с поиском острова, найти его, и понять, является он прилегающим к краям, если да, то его координаты не запоминаем.
                В конце закрашиваем те переменные, которые сохранили.
                ИЛИ
                От обратного, пройтись только по всем краям, не по всем элементам. Найти острова прилегающие, поменять элементы на Т.
                Пройтись по всему массиву, меняя О на Х, а Т на О (это лучше)
           `,
        },
        {
            title: 'Rotting Oranges',
            descriptionImg: 'graph-4.PNG',
            solution: `
            ${orangesRotting.toString().split('\n').join('<br/>')} <br><br>
            `,
            remember: `
                Находим один несвежий апельсик, проходимся DFS. В очереди будет трехмерный массив.
                Верхний цикл по очереди
                каждый элемент очереди - это слой соседних элементов, проходимся по ним, проверяя все нужные коодинаты
                После окончания массива, если хоть один элемент мы поменяли, увеличиваем время

                Возвращаем время-1, потому что при нашем алгоритме мы меняем найденный элемент первый, что был испорченным 2
                <br>
                <br>
                ИЛИ
                <br>
                <br>
                (Если у нас может быть несколько апельсинов)
                Пройтись по всему массиву, подсчитать колво свежих апельсинов + добавить в очередь все не свежие.
                Цикл по очереди и проверка, что остались свежие ->
                Цикл по очереди по текущей длине без добавления, берем элемент,
                проходимся по всем направлениям, получая координаты
                проверяем, что эти координаты внутри поля и равен свежему,
                если так, то меняем его на несвежий и добавляем координаты в очередь, уменьшая колво свежих апельсинов.
                После внутреннего цикла увеличиваем колво времени.
                Возвращаем время, если свежих апельсинов 0, иначе -1
           `,
        },
        {
            title: 'Course Schedule',
            descriptionImg: 'graph-5.PNG',
            solution: `
            ${canFinish.toString().split('\n').join('<br/>')} <br><br>
            `,
        },
        {
            title: 'Graph Valid Tree',
            descriptionImg: 'graph-6.PNG',
            solution: `
            ${canFinish.toString().split('\n').join('<br/>')} <br><br>
            `,
            remember: `
            Создаем граф, связывая ноды друг с другом (проходим по всем ребрам, одно значение в массив по индексу, второе - во второе).
            DFS (передаем текущий эл и прошлый) - бейс кейсы, если уже встречали такую ноду. Если еще нет, добавляем. Проходимся по тем узлам, что связан конкретно этот.
            Если встречаем прошлый, то continue. Вызываем dfs (новой ноды,текущей), если false, возвращаем false.
            Если цикл весь прошел, то true.
            <br>
            Все корректно, если и поиск вернул true, и колво visited нод будет такое же, что и изначально ребер.
            `,
        },
        {
            title: 'Alien Dictionary ',
            descriptionImg: 'graph-7.PNG',
            solution: `
            ${alienOrder.toString().split('\n').join('<br/>')} <br><br>
            `,
            remember: `
            Создать список смежности каждого уникального символа (a->[b]),
            перебор циклом по смежным словам, проверяя, является ли второе слово префиксом первого (возвращаем "")
            Проверяем по буквенно, если нашли несовпадение, добавляем в букву первого слово ссылку на второе.
            <br> Preorder DFS (почитать). Бейз кейс, что уже видели этот символ (вернуть visited[c])  visited = {}; // false = visited, true = current path
            , потом цикл DFS по соседям, проверяя вернул ли кто-то true, елси да, возвращаем. Помечаем visited = false и добавляем символ в массив результат. Возвращаем
            результат, реверс, джоин
            `,
        },
    ];

    created() {
        // console.log(getUniqSolution([2, 3, 6, 7], 7));
        // console.log(
        //     getAmountOfIslands([
        //         ['1', '1', '0', '0', '0'],
        //         ['1', '1', '0', '0', '0'],
        //         ['0', '0', '1', '0', '0'],
        //         ['0', '0', '0', '1', '1'],
        //     ]),
        //     [
        //         ['1', '1', '0', '0', '0'],
        //         ['1', '1', '0', '0', '0'],
        //         ['0', '0', '1', '0', '0'],
        //         ['0', '0', '0', '1', '1'],
        //     ]
        // );
    }
}
</script>
